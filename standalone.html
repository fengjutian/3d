<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>独立3D模型查看器</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info { position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; font-family: Arial, sans-serif; font-size: 12px; z-index: 1000; }
    </style>
</head>
<body>
    <div id="info">
        <h3>3D模型查看器</h3>
        <p>状态: <span id="status">初始化中...</span></p>
        <p>使用鼠标: 拖动旋转, 滚轮缩放, Shift+拖动平移</p>
    </div>

    <!-- 直接引入Three.js库 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js"></script>

    <script>
        // 全局变量
        let scene, camera, renderer, controls, model;

        // 初始化函数
        function init() {
            // 创建场景
            scene = new THREE.Scene();

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 创建控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // 添加地面
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.ShadowMaterial({ opacity: 0.3 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            // 加载HDR环境贴图
            const hdrLoader = new THREE.RGBELoader();
            hdrLoader.load('./textures/studio_small_08_4k.hdr', function(texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                scene.background = texture;
            });

            // 加载模型
            loadModel();

            // 窗口大小调整监听
            window.addEventListener('resize', onWindowResize);

            // 开始动画循环
            animate();
        }

        // 加载模型函数
        function loadModel() {
            document.getElementById('status').textContent = '正在加载模型...';
            
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                './models/model.glb',
                
                function(gltf) {
                    console.log('模型加载成功!');
                    document.getElementById('status').textContent = '模型加载成功';
                    
                    model = gltf.scene;
                    
                    // 设置模型阴影
                    model.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    scene.add(model);
                    
                    // 自动定位相机到模型
                    centerCamera();
                    
                    // 如果有动画，播放动画
                    if (gltf.animations && gltf.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(model);
                        gltf.animations.forEach(function(clip) {
                            mixer.clipAction(clip).play();
                        });
                        scene.userData.mixer = mixer;
                    }
                },
                
                function(xhr) {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    document.getElementById('status').textContent = `加载中: ${percent}%`;
                },
                
                function(error) {
                    console.error('模型加载错误:', error);
                    document.getElementById('status').textContent = '模型加载失败';
                    alert('模型加载失败: ' + (error.message || '未知错误'));
                }
            );
        }

        // 自动定位相机到模型
        function centerCamera() {
            if (!model) return;
            
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5;
            
            camera.position.set(center.x, center.y + maxDim * 0.5, center.z + cameraZ);
            controls.target.copy(center);
            controls.update();
        }

        // 窗口大小调整处理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            if (scene.userData.mixer) {
                scene.userData.mixer.update(0.016); // 约60fps
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // 启动应用
        window.onload = init;
    </script>
</body>
</html>